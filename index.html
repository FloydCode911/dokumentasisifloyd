<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/atom-one-dark.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    <title>Dokumentasi Bot Discord</title>

</head>
<button id="theme-toggle" style="position: fixed; top: 10px; right: 10px; z-index: 1000; padding: 5px 10px; background-color: #f0f0f0; border: none; border-radius: 5px; cursor: pointer;">
    ðŸŒ“ Toggle Theme
</button>
<body>

<h1>Dokumentasi Bot Discord</h1>

<p>Dokumentasi ini menjelaskan secara detail setiap baris dan fungsi dari kode bot yang menggunakan Discord.py. Kode ini mencakup fungsi terjemahan bahasa serta perubahan status bot secara berkala. Berikut adalah penjelasan lengkap baris demi baris.</p>

<h2>Import Modul dan Pustaka</h2>
<pre><code>import discord
import random
import requests
import asyncio
import io
from discord.ext import commands, tasks
from discord import app_commands
from googletrans import Translator
from datetime import datetime</code></pre>

<p>Pada bagian ini, kita mengimpor berbagai modul dan pustaka yang dibutuhkan:</p>
<ul>
    <li><code>discord</code>: Pustaka utama untuk membuat bot Discord.</li>
    <li><code>random</code>: Digunakan untuk melakukan operasi acak (tidak digunakan pada kode ini, bisa dihapus jika tidak diperlukan).</li>
    <li><code>requests</code>: Digunakan untuk melakukan permintaan HTTP (juga tidak digunakan di sini).</li>
    <li><code>asyncio</code>: Modul untuk menangani operasi asinkron, penting untuk bot Discord.</li>
    <li><code>io</code>: Digunakan untuk operasi input/output (tidak digunakan).</li>
    <li><code>commands</code> dan <code>tasks</code> dari <code>discord.ext</code>: Digunakan untuk membuat perintah dan tugas terjadwal.</li>
    <li><code>app_commands</code>: Untuk membuat perintah slash (perintah berbasis slash/garis miring).</li>
    <li><code>googletrans</code>: Untuk terjemahan otomatis dengan API Google Translate.</li>
    <li><code>datetime</code>: Untuk menangani waktu dan tanggal, seperti penambahan timestamp pada embed Discord.</li>
</ul>

<h2>Konfigurasi Bot</h2>
<pre><code>intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix='?', intents=intents)
translator = Translator()
OMDB_API_TOKEN = ''
BOT_TOKEN = ""</code></pre>

<p>Pada bagian ini, kita mengonfigurasi bot Discord:</p>
<ul>
    <li><code>intents = discord.Intents.default()</code>: Membuat instance <code>Intents</code> default, yang berfungsi untuk mengatur izin akses bot terhadap informasi di server.</li>
    <li><code>intents.message_content = True</code>: Mengizinkan bot untuk mengakses konten pesan pengguna.</li>
    <li><code>bot = commands.Bot(command_prefix='?', intents=intents)</code>: Membuat instance bot dengan awalan perintah <code>'?'</code>. Artinya, setiap perintah harus diawali dengan karakter ini, misalnya <code>?translate</code>.</li>
    <li><code>translator = Translator()</code>: Membuat instance <code>Translator</code> dari pustaka <code>googletrans</code> untuk digunakan dalam menerjemahkan teks.</li>
    <li><code>OMDB_API_TOKEN</code>: Token API untuk mengakses OMDB (tidak digunakan dalam kode ini).</li>
    <li><code>BOT_TOKEN</code>: Token otentikasi bot Discord yang harus dijaga kerahasiaannya. Token ini digunakan untuk menghubungkan bot ke server Discord.</li>
</ul>

<h2>Event Saat Bot Siap</h2>
<pre><code>@bot.event
async def on_ready():
    await bot.tree.sync()  # Sinkronisasi command slash
    print(f'Logged in as {bot.user}')
    rotate_status.start()  # Memulai tugas rotasi status</code></pre>

<p>Bagian ini mendefinisikan event <code>on_ready</code>, yang dipanggil ketika bot berhasil login dan siap digunakan:</p>
<ul>
    <li><code>@bot.event</code>: Mendefinisikan sebuah event handler.</li>
    <li><code>async def on_ready()</code>: Fungsi asinkron yang berjalan saat bot siap digunakan.</li>
    <li><code>await bot.tree.sync()</code>: Mengsinkronkan perintah <code>slash</code> secara global.</li>
    <li><code>rotate_status.start()</code>: Memulai fungsi rotasi status bot yang didefinisikan di bagian selanjutnya.</li>
</ul>

<h2>Rotasi Status Bot</h2>
<pre><code>@tasks.loop(seconds=5)
async def rotate_status():
    status_messages = [
        discord.Game(name="Cek Khodam ?khodam @username"),
        discord.Activity(type=discord.ActivityType.watching, name='Type /help')
    ]
    for status in status_messages:
        await bot.change_presence(status=discord.Status.online, activity=status)
        await asyncio.sleep(4)</code></pre>

<p>Fungsi ini membuat status bot berganti setiap beberapa detik. Penjelasannya:</p>
<ul>
    <li><code>@tasks.loop(seconds=5)</code>: Dekorator yang membuat fungsi dijalankan setiap 5 detik sekali.</li>
    <li><code>status_messages</code>: Sebuah daftar berisi status yang akan diputar oleh bot. Pada contoh ini, status pertama adalah game yang sedang dimainkan, sedangkan status kedua menunjukkan aktivitas menonton.</li>
    <li><code>for status in status_messages</code>: Melakukan iterasi (pengulangan) pada daftar status.</li>
    <li><code>await bot.change_presence(status=discord.Status.online, activity=status)</code>: Mengubah status bot menjadi online dan menetapkan aktivitas dari iterasi.</li>
    <li><code>await asyncio.sleep(4)</code>: Memberikan jeda selama 4 detik sebelum mengganti ke status berikutnya.</li>
</ul>

<h2>Perintah Terjemahan</h2>
<pre><code>@bot.tree.command(name="translate", description="Translate English - Indonesia - Jawa - Sunda")
@app_commands.describe(sentence="Sentence to translate")
@app_commands.choices(target_language=[
    app_commands.Choice(name="English", value="en"),
    app_commands.Choice(name="Indonesian", value="id"),
    app_commands.Choice(name="Javanese", value="jw"),
    app_commands.Choice(name="Sundanese", value="su")
])
async def translate_text(interaction: discord.Interaction, sentence: str, target_language: app_commands.Choice[str]):
    try:
        translated_text = translator.translate(sentence, dest=target_language.value).text
        embed = discord.Embed(title="Translation Result", color=0x2596be)
        embed.set_author(name=f'{interaction.user.name}\'s Message', icon_url=interaction.user.display_avatar.url)
        embed.add_field(name="Original", value=sentence, inline=False)
        embed.add_field(name="Translated", value=translated_text, inline=False)
        embed.set_thumbnail(url=interaction.user.display_avatar.url)
        timestamp = datetime.now().strftime("%A, %B %d, %Y at %H:%M:%S")
        embed.set_footer(text=f"Translated to {target_language.name} on {timestamp}")
        await interaction.response.send_message(embed=embed)
    except Exception as error:
        print(f"Translation error: {error}")
        await interaction.response.send_message("Sorry, an error occurred during translation.")</code></pre>

<p>Ini adalah perintah <code>slash</code> yang memungkinkan pengguna untuk menerjemahkan kalimat ke beberapa bahasa yang didukung. Penjelasan:</p>
<ul>
    <li><code>@bot.tree.command(name="translate", description="Translate English - Indonesia - Jawa - Sunda")</code>: Mendefinisikan perintah dengan nama <code>translate</code> yang akan diterima bot, serta deskripsi tentang fungsi perintah tersebut.</li>
    <li><code>@app_commands.describe(sentence="Sentence to translate")</code>: Menjelaskan parameter <code>sentence</code>, yaitu kalimat yang ingin diterjemahkan.</li>
    <li><code>@app_commands.choices(target_language=[...])</code>: Menetapkan pilihan bahasa tujuan untuk terjemahan. Ada empat pilihan: <code>English</code>, <code>Indonesian</code>, <code>Javanese</code>, dan <code>Sundanese</code> dengan kode masing-masing: <code>en</code> untuk Inggris, <code>id</code> untuk Indonesia, <code>jw</code> untuk Jawa, dan <code>su</code> untuk Sunda.</li>
    <li><code>async def translate_text(interaction: discord.Interaction, sentence: str, target_language: app_commands.Choice[str])</code>: Fungsi asinkron untuk memproses perintah terjemahan. Parameter yang digunakan adalah <code>interaction</code> yang mewakili interaksi pengguna, <code>sentence</code> yang berisi kalimat yang akan diterjemahkan, dan <code>target_language</code> yang menentukan bahasa tujuan terjemahan.</li>
</ul>

<p>Dalam fungsi ini, kita memiliki beberapa langkah:</p>
<ul>
    <li><code>translator.translate(sentence, dest=target_language.value).text</code>: Menggunakan instance <code>translator</code> untuk menerjemahkan teks <code>sentence</code> ke bahasa tujuan yang ditentukan oleh <code>target_language.value</code>. Hasilnya adalah teks terjemahan.</li>
    <li><code>embed = discord.Embed(...)</code>: Membuat pesan <code>embed</code> untuk menampilkan hasil terjemahan dalam bentuk yang rapi di Discord.</li>
    <li><code>embed.set_author(...)</code>: Menambahkan nama pengguna dan gambar profil pengguna ke dalam embed, sehingga jelas siapa yang meminta terjemahan.</li>
    <li><code>embed.add_field(...)</code>: Menambahkan dua field ke dalam embed:
        <ul>
            <li><code>name="Original"</code>: Menampilkan kalimat asli sebelum diterjemahkan.</li>
            <li><code>name="Translated"</code>: Menampilkan hasil terjemahan.</li>
        </ul>
    </li>
    <li><code>embed.set_thumbnail(...)</code>: Menambahkan gambar kecil berupa avatar pengguna yang melakukan permintaan terjemahan.</li>
    <li><code>timestamp = datetime.now().strftime(...)</code>: Membuat timestamp untuk menandai kapan terjemahan dilakukan, dengan format yang spesifik (misalnya, "Senin, 14 Oktober 2024 pukul 16:30:45").</li>
    <li><code>embed.set_footer(...)</code>: Menambahkan catatan di bagian bawah embed, yang mencakup bahasa tujuan terjemahan dan timestamp.</li>
    <li><code>await interaction.response.send_message(embed=embed)</code>: Mengirimkan pesan terjemahan dalam bentuk embed ke saluran Discord tempat perintah dikirim.</li>
</ul>

<h3>Penanganan Error</h3>
<p>Bagian <code>try-except</code> digunakan untuk menangani kemungkinan kesalahan selama proses terjemahan:</p>
<ul>
    <li><code>try:</code> Blok ini mencoba menjalankan fungsi terjemahan.</li>
    <li><code>except Exception as error:</code> Jika terjadi kesalahan, blok ini akan menangkapnya dan menampilkan pesan kesalahan di konsol dengan <code>print(f"Translation error: {error}")</code>. Selain itu, bot juga akan mengirimkan pesan kesalahan ke pengguna di Discord.</li>
</ul>

<h1>Dokumentasi Fungsi Transformasi Teks</h1>
<p>Kode berikut bertujuan untuk membuat perintah baru bernama <code>godvlan</code> yang mengambil teks dari pengguna, mengubah karakter 'p' menjadi 'v', lalu memodifikasi huruf hidup (a, i, u, e, o) dengan menambahkan huruf 'm' setelahnya. Selain itu, bagian akhir dari setiap kata yang lebih dari dua huruf tetap dipertahankan.</p>

<h2>Definisi Perintah</h2>
<pre><code>@bot.tree.command(name="godvlan", description="OmkeGams")
async def transform_text(interaction: discord.Interaction, input_text: str):
    ðŸ¤“
</code></pre>

<ul>
    <li><code>@bot.tree.command(name="godvlan", description="OmkeGams")</code>: Mendefinisikan perintah baru bernama <code>godvlan</code> yang dapat digunakan di Discord. Deskripsi perintah adalah <code>"OmkeGams"</code> yang memberikan sedikit informasi tentang apa yang dilakukan perintah ini.</li>
    <li><code>async def transform_text(interaction: discord.Interaction, input_text: str)</code>: Fungsi asinkron yang bertanggung jawab memproses input dari pengguna. Parameter <code>interaction</code> digunakan untuk mendapatkan informasi tentang interaksi yang terjadi, sementara <code>input_text</code> adalah teks yang diberikan pengguna untuk dimodifikasi.</li>
</ul>

<h2>Transformasi Teks</h2>
<pre><code>original_text = input_text
modified_text = input_text.replace('p', 'v').replace('P', 'V')
    ðŸ¤“
</code></pre>

<ul>
    <li><code>original_text = input_text</code>: Menyimpan teks asli yang diberikan oleh pengguna dalam variabel <code>original_text</code>. Ini dilakukan untuk menampilkan teks asli nanti di hasil akhir.</li>
    <li><code>modified_text = input_text.replace('p', 'v').replace('P', 'V')</code>: Mengubah teks asli dengan mengganti semua huruf 'p' kecil menjadi 'v', dan huruf 'P' besar menjadi 'V'. Proses ini dilakukan secara langsung pada teks input menggunakan fungsi <code>replace</code> dari Python.</li>
</ul>

<h2>Memecah dan Memodifikasi Kata</h2>
<pre><code>words = modified_text.split()
transformed_words = []
for word in words:
    if len(word) > 2:
        word_body = word[:-2]
        word_suffix = word[-2:]
        transformed_body = ''.join([ch + 'm' if ch.lower() in 'aiueo' else ch for ch in word_body])
        final_word = transformed_body + word_suffix
    else:
        final_word = word
    transformed_words.append(final_word)</code></pre>

<p>Pada bagian ini, teks yang sudah dimodifikasi diproses lebih lanjut. Penjelasan tiap barisnya:</p>

<ul>
    <li><code>words = modified_text.split()</code>: Menggunakan fungsi <code>split()</code> untuk memecah teks menjadi daftar kata-kata berdasarkan spasi. Setiap kata dalam teks diubah menjadi elemen di dalam list <code>words</code>.</li>
    <li><code>transformed_words = []</code>: Membuat list kosong bernama <code>transformed_words</code> untuk menyimpan hasil kata-kata yang sudah dimodifikasi nantinya.</li>
    <li><code>for word in words:</code>: Memulai perulangan untuk setiap kata dalam list <code>words</code>.</li>
</ul>

<b> Di dalam perulangan:</b>
<ul>
    <li><code>if len(word) > 2:</code>: Mengecek apakah panjang kata lebih dari 2 huruf. Jika ya, maka kata tersebut akan dimodifikasi. Jika tidak, kata akan langsung disimpan tanpa perubahan.</li>
    
    <li><code>word_body = word[:-2]</code>: Mengambil bagian kata kecuali dua huruf terakhir. <code>[:-2]</code> adalah slicing untuk mendapatkan semua huruf kecuali dua huruf terakhir dari kata.</li>
    <li><code>word_suffix = word[-2:]</code>: Mengambil dua huruf terakhir dari kata untuk dipertahankan tanpa perubahan. <code>[-2:]</code> adalah slicing untuk mengambil dua huruf terakhir.</li>

    <li><code>transformed_body = ''.join([ch + 'm' if ch.lower() in 'aiueo' else ch for ch in word_body])</code>: Bagian ini sangat penting karena melakukan modifikasi pada huruf hidup dalam <code>word_body</code> (bagian kata kecuali dua huruf terakhir). Penjelasan lebih lanjut:
        <ul>
            <li><code>for ch in word_body</code>: Perulangan untuk setiap karakter dalam bagian kata yang sudah di-slice.</li>
            <li><code>if ch.lower() in 'aiueo'</code>: Mengecek apakah karakter tersebut adalah huruf hidup (vokal). Fungsi <code>lower()</code> memastikan bahwa pengecekan dilakukan tanpa memperhatikan huruf besar atau kecil.</li>
            <li><code>ch + 'm'</code>: Jika karakter adalah huruf vokal, tambahkan huruf 'm' setelahnya.</li>
            <li><code>else ch</code>: Jika karakter bukan vokal, biarkan tanpa perubahan.</li>
            <li><code>''.join([...])</code>: Gabungkan kembali semua karakter yang sudah dimodifikasi ke dalam satu string.</li>
        </ul>
    </li>

    <li><code>final_word = transformed_body + word_suffix</code>: Gabungkan bagian kata yang sudah dimodifikasi dengan dua huruf terakhir yang tidak dimodifikasi, membentuk kata akhir yang sudah diubah.</li>
    <li><code>else: final_word = word</code>: Jika panjang kata 2 huruf atau kurang, maka kata tidak diubah dan langsung disimpan sebagai <code>final_word</code>.</li>
    <li><code>transformed_words.append(final_word)</code>: Tambahkan kata yang sudah dimodifikasi (atau tidak dimodifikasi) ke dalam list <code>transformed_words</code>.</li>
</ul>

<h2>Menggabungkan Kata-Kata yang Sudah Dimodifikasi</h2>
<pre><code>final_text = ' '.join(transformed_words)</code></pre>

<ul>
    <li><code>final_text = ' '.join(transformed_words)</code>: Menggabungkan kembali semua kata yang sudah dimodifikasi menjadi satu string, dengan spasi sebagai pemisah antar kata.</li>
</ul>

<h2>Menampilkan Hasil</h2>
<pre><code>await interaction.response.send_message(f'```Original: {original_text}\nResult: {final_text}```')
    ðŸ¤“
    ðŸ¤“
</code></pre>

<ul>
    <li><code>await interaction.response.send_message(...)</code>: Mengirimkan pesan hasil transformasi teks ke Discord. Pesan ini ditampilkan dalam format kode blok menggunakan tiga backtick <code>```</code>, dengan teks asli dan hasil modifikasi dipisahkan oleh baris baru <code>\n</code>.</li>
</ul>

<h2>Kesimpulan</h2>
<p>Fungsi ini mengambil teks dari pengguna, mengganti huruf 'p' dengan 'v', menambahkan huruf 'm' setelah vokal, dan menjaga dua huruf terakhir dari setiap kata. Kode ini mencakup berbagai konsep Python seperti <code>replace</code>, <code>split</code>, slicing, serta manipulasi string menggunakan <code>join</code> dan <code>list comprehension</code>.</p>

<h1>Penjelasan Fungsi Bot Khodam</h1>

<div class="section">
    <h2>Kode Python</h2>
    <pre>
<pre><code>@bot.command()
async def khodam(ctx, user: discord.Member, *, additional_text: str = ""):
print(f"Khodam command triggered for user: {user}")
khodam_options = [
    "Blower Pabrik", "Jin rusdidy", "Arwah Ambalingham", "Super muani",
    "Budie arie", "Jon snow", "mulyono", "fufufafa", "Gus fring",
    "Mr white", "Jesse pinkman", "kapal karam", "p diddy", "Bayi michael jackson",
    "Brewog audio", "Habib rizieq", "Ambatron", "Rusdi shelby", "Mas fuad",
    "Tumis kangkung", "Keripik Garing", "Pocong Bersepeda", "Kipas Rusak", "Kuliah Online",
    "Remote TV", "Jawa timur", "Laba - laba Sunda", "Laba - laba Jawa"
]
chosen_khodam = random.choice(khodam_options)
response = f'Khodam yang ada di dalam tubuh {user.mention}, adalah "{chosen_khodam}"'
if additional_text:
    response += f" ({additional_text})"
message = await ctx.reply(response)
await message.add_reaction('ðŸ‘»')</code></pre>
    </pre>
</div>

<div class="section">
    <h2>Penjelasan Kode Baris per Baris</h2>
    <ul>
        <li><code>@bot.command()</code>: Ini adalah dekorator yang memberi tahu bot bahwa fungsi di bawahnya adalah sebuah perintah bot yang bisa dijalankan pengguna.</li>
        <li><code>async def khodam(...)</code>: Ini mendefinisikan fungsi asinkron bernama <code>khodam</code>. Ini adalah perintah bot yang bisa dipanggil oleh pengguna.</li>
        <li><code>ctx</code>: Objek konteks yang memuat informasi tentang interaksi seperti channel dan server.</li>
        <li><code>user: discord.Member</code>: Parameter ini adalah pengguna Discord yang disebut dalam perintah.</li>
        <li><code>additional_text: str = ""</code>: Parameter opsional yang memungkinkan pengguna menambahkan teks tambahan.</li>
        <li><code>print(f"Khodam command triggered for user: {user}")</code>: Menampilkan pesan di terminal atau log saat perintah ini dipanggil, membantu debugging.</li>
        <li><code>khodam_options</code>: Ini adalah list yang berisi beberapa opsi khodam, berupa string yang nantinya akan dipilih secara acak oleh bot.</li>
        <li><code>chosen_khodam = random.choice(khodam_options)</code>: Memilih khodam secara acak dari list <code>khodam_options</code> menggunakan fungsi <code>random.choice()</code>.</li>
        <li><code>response = f'Khodam...'</code>: Membuat string respon dengan menyisipkan <code>user.mention</code> dan khodam yang dipilih secara acak.</li>
        <li><code>if additional_text:</code>: Mengecek apakah ada teks tambahan yang diberikan pengguna. Jika ada, teks tersebut ditambahkan ke dalam respon.</li>
        <li><code>message = await ctx.reply(response)</code>: Mengirimkan pesan balasan ke channel dengan teks yang sudah dirangkai.</li>
        <li><code>await message.add_reaction('ðŸ‘»')</code>: Menambahkan reaksi emoji hantu ðŸ‘» ke pesan yang baru dikirim.</li>
    </ul>
</div>

<h1>Penjelasan Kode Movie Bot</h1>

<div class="section">
    <h2>Kode Python: fetch_movie_data</h2>
    <pre>
<pre><code>def fetch_movie_data(movie_title):
api_url = f'http://www.omdbapi.com/?t={movie_title}&apikey={OMDB_API_TOKEN}'
response = requests.get(api_url)

if response.status_code == 200:
    movie_data = response.json()
    if movie_data['Response'] == 'True':
        return {
            "title": movie_data.get("Title", "N/A"),
            "url": f'https://www.imdb.com/title/{movie_data.get("imdbID", "")}',
            "type": movie_data.get("Type", "N/A"),
            "score": movie_data.get("imdbRating", "N/A"),
            "votes": movie_data.get("imdbVotes", "N/A").replace(",", ""),
            "release_date": movie_data.get("Released", "N/A"),
            "plot": movie_data.get("Plot", "N/A"),
            "poster": movie_data.get("Poster", "N/A"),
            "genres": movie_data.get("Genre", "").split(", "),
            "year": movie_data.get("Year", "N/A"),
            "rated": movie_data.get("Rated", "N/A"),
            "runtime": movie_data.get("Runtime", "N/A"),
            "director": movie_data.get("Director", "N/A"),
            "writer": movie_data.get("Writer", "N/A"),
            "actors": movie_data.get("Actors", "N/A"),
            "language": movie_data.get("Language", "N/A"),
            "country": movie_data.get("Country", "N/A"),
            "awards": movie_data.get("Awards", "N/A"),
            "ratings": movie_data.get("Ratings", [])
        }
    else:
        return {"error": "Movie not found"}
else:
    return {"error": "Failed to fetch data"}
</code></pre>
</div>

<div class="section">
    <h2>Penjelasan Baris per Baris</h2>
    <ul>
        <li><code>def fetch_movie_data(movie_title):</code> Membuat fungsi bernama <code>fetch_movie_data</code> yang menerima parameter <code>movie_title</code>, judul film yang ingin dicari datanya dari API OMDB.</li>
        <li><code>api_url = ...</code>: Menggabungkan judul film yang diinputkan dengan URL OMDB API menggunakan f-string, menambahkan <code>movie_title</code> dan <code>OMDB_API_TOKEN</code> yang merupakan token API untuk otentikasi.</li>
        <li><code>response = requests.get(api_url)</code>: Menggunakan library <code>requests</code> untuk melakukan HTTP GET request ke URL API yang sudah dibuat di atas.</li>
        <li><code>if response.status_code == 200:</code> Mengecek apakah HTTP response sukses (status 200). Jika ya, kode di dalam blok ini akan dijalankan.</li>
        <li><code>movie_data = response.json()</code>: Mengubah data response dari format JSON ke bentuk Python dictionary menggunakan <code>.json()</code>.</li>
        <li><code>if movie_data['Response'] == 'True':</code> Memastikan bahwa data film yang diminta benar-benar ada dengan mengecek apakah nilai <code>Response</code> dari API adalah "True".</li>
        <li><code>return {...}</code>: Mengembalikan sebuah dictionary yang berisi berbagai data tentang film, seperti judul, URL IMDb, skor, plot, poster, genre, tahun, sutradara, dan banyak lagi. Jika data tidak ada, default-nya adalah "N/A".</li>
        <li><code>else:</code> Jika film tidak ditemukan, mengembalikan dictionary dengan kunci "error" dan pesan "Movie not found".</li>
        <li><code>else:</code> Jika permintaan API gagal (tidak status 200), mengembalikan dictionary dengan kunci "error" dan pesan "Failed to fetch data".</li>
    </ul>
</div>

<div class="section">
    <h2>Kode Python: movie command</h2>
<pre><code>@bot.command()
async def movie(ctx, *, movie_title: str):
movie_info = fetch_movie_data(movie_title)

if "error" in movie_info:
    await ctx.reply(movie_info["error"], mention_author=True)
else:
    embed = discord.Embed(title=movie_info['title'], url=movie_info['url'], description=movie_info['plot'], color=0x2596be)
    embed.add_field(name="Year", value=movie_info['year'], inline=True)
    embed.add_field(name="Rated", value=movie_info['rated'], inline=True)
    embed.add_field(name="Released", value=movie_info['release_date'], inline=True)
    embed.add_field(name="Runtime", value=movie_info['runtime'], inline=True)
    embed.add_field(name="Genre", value=", ".join(movie_info['genres']), inline=True)
    embed.add_field(name="Director", value=movie_info['director'], inline=True)
    embed.add_field(name="Writer", value=movie_info['writer'], inline=True)
    embed.add_field(name="Actors", value=movie_info['actors'], inline=True)
    embed.add_field(name="Language", value=movie_info['language'], inline=True)
    embed.add_field(name="Country", value=movie_info['country'], inline=True)
    embed.add_field(name="Awards", value=movie_info['awards'], inline=True)
    embed.add_field(name="IMDb Rating", value=movie_info['score'], inline=True)
    embed.add_field(name="Votes", value=movie_info['votes'], inline=True)
    embed.set_image(url=movie_info['poster'])
    await ctx.reply(embed=embed, mention_author=True)
</code></pre>
</div>

<div class="section">
    <h2>Penjelasan Baris per Baris</h2>
    <ul>
        <li><code>@bot.command()</code>: Menentukan bahwa fungsi <code>movie</code> adalah sebuah perintah bot yang dapat dipanggil pengguna di Discord.</li>
        <li><code>async def movie(ctx, *, movie_title: str):</code> Mendefinisikan fungsi asinkron <code>movie</code> yang menerima dua parameter: <code>ctx</code> (konteks pesan) dan <code>movie_title</code> (judul film yang akan dicari).</li>
        <li><code>movie_info = fetch_movie_data(movie_title)</code>: Memanggil fungsi <code>fetch_movie_data</code> dengan parameter <code>movie_title</code> untuk mendapatkan data tentang film dari API OMDB.</li>
        <li><code>if "error" in movie_info:</code> Mengecek apakah terdapat kunci "error" di dalam hasil data film yang didapat. Jika ada, artinya terjadi kesalahan (film tidak ditemukan atau gagal mengambil data).</li>
        <li><code>await ctx.reply(movie_info["error"], mention_author=True)</code>: Jika terjadi kesalahan, bot akan membalas pesan dengan error message yang sesuai, dan menyebut pengirim pesan (author).</li>
        <li><code>else:</code> Jika tidak ada kesalahan, maka data film akan ditampilkan menggunakan pesan terstruktur dengan format embed.</li>
        <li><code>embed = discord.Embed(...)</code>: Membuat sebuah embed Discord untuk menampilkan informasi film dengan judul, URL IMDb, deskripsi, dan warna background embed.</li>
        <li><code>embed.add_field(...)</code>: Menambahkan berbagai detail film ke dalam embed, seperti tahun, rating, tanggal rilis, genre, sutradara, penulis, pemeran, bahasa, negara, dan penghargaan.</li>
        <li><code>embed.set_image(url=movie_info['poster'])</code>: Menambahkan poster film sebagai gambar di dalam embed.</li>
        <li><code>await ctx.reply(embed=embed, mention_author=True)</code>: Mengirimkan embed berisi informasi film sebagai balasan kepada pengguna, dan menyebut pengirim pesan.</li>
    </ul>
</div>

<h1>Penjelasan Kode Ask AI Command</h1>

<div class="section">
    <h2>Kode Python: ask_ai</h2>
<pre><code>
@bot.tree.command(name="ai", description="Ask AI anything")
async def ask_ai(interaction: discord.Interaction, prompt: str):
await interaction.response.defer()
try:
    ai_response = requests.get(
        'https://api.Your.api',
        params={'text': prompt},
        headers={'accept': 'application/json'}
    )
    if ai_response.status_code == 200:
        ai_data = ai_response.json()
        print("AI data fetched successfully")
        if 'answer' in ai_data:
            timestamp = datetime.now().strftime("%A, %B %d, %Y at %H:%M:%S")
            embed = discord.Embed(title="Gemini's Response", description=ai_data['answer'], color=0x2596be)
            embed.set_author(name=f'{interaction.user.name}\'s Question', icon_url=interaction.user.display_avatar.url)
            embed.set_thumbnail(url=interaction.user.display_avatar.url)
            embed.set_footer(text=f"Asked on {timestamp}")
            await asyncio.sleep(1)
            await interaction.edit_original_response(embed=embed)
        else:
            await interaction.edit_original_response(content="Invalid AI response")
    else:
        await interaction.edit_original_response(content="Failed to get AI response")
except Exception as error:
    await interaction.edit_original_response(content=f"Error: {error}")
</code></pre>
</div>

<div class="section">
    <h2>Penjelasan Baris per Baris</h2>
    <ul>
        <li><code>@bot.tree.command(name="ai", description="Ask AI anything")</code>: Mendefinisikan sebuah perintah bot bernama <code>ai</code> yang bisa digunakan untuk bertanya kepada AI. Deskripsi menjelaskan bahwa perintah ini memungkinkan pengguna untuk menanyakan apa saja.</li>

        <li><code>async def ask_ai(interaction: discord.Interaction, prompt: str):</code> Mendefinisikan fungsi asinkron <code>ask_ai</code> yang menerima dua parameter: <code>interaction</code> (interaksi yang terjadi di Discord) dan <code>prompt</code> (pertanyaan atau input dari pengguna).</li>

        <li><code>await interaction.response.defer()</code>: Menunda pengiriman respon langsung untuk memberi waktu lebih pada proses asynchronous (seperti menunggu respon dari API) agar bot tidak timeout.</li>

        <li><code>try:</code> Memulai blok <code>try</code> untuk menangani potensi error dalam kode yang bisa muncul dari panggilan API eksternal atau bagian lain dari kode.</li>

        <li><code>ai_response = requests.get(...)</code>: Mengirimkan request GET ke API <code>https://api.Your.api</code> dengan parameter <code>prompt</code> yang berisi teks atau pertanyaan pengguna. API akan memberikan respon berdasarkan input tersebut.</li>

        <li><code>params={'text': prompt}</code>: Mengirimkan parameter <code>prompt</code> sebagai nilai dari parameter <code>text</code> di dalam query API untuk menyampaikan pertanyaan pengguna.</li>

        <li><code>headers={'accept': 'application/json'}</code>: Menetapkan bahwa kita mengharapkan respon dari API dalam format JSON.</li>

        <li><code>if ai_response.status_code == 200:</code> Memeriksa apakah respon dari server memiliki status kode 200, yang berarti permintaan berhasil.</li>

        <li><code>ai_data = ai_response.json()</code>: Mengkonversi data dari format JSON ke bentuk dictionary Python menggunakan <code>.json()</code>.</li>

        <li><code>print("AI data fetched successfully")</code>: Mencetak pesan di konsol yang menunjukkan bahwa data berhasil diambil dari API. Ini untuk debugging dan pengecekan saat pengembangan.</li>

        <li><code>if 'answer' in ai_data:</code> Memeriksa apakah respon dari AI mengandung kunci <code>answer</code>, yang menyimpan jawaban dari AI untuk pertanyaan pengguna.</li>

        <li><code>timestamp = datetime.now().strftime(...)</code>: Mengambil waktu saat ini dan mengubahnya menjadi format yang mudah dibaca, seperti hari, bulan, tanggal, dan waktu. Ini digunakan untuk menunjukkan kapan pertanyaan ditanyakan.</li>

        <li><code>embed = discord.Embed(...)</code>: Membuat objek <code>Embed</code> baru di Discord yang berisi jawaban AI. Embed adalah cara yang menarik dan terstruktur untuk menampilkan informasi di Discord.</li>

        <li><code>embed.set_author(...)</code>: Menetapkan nama pengguna yang menanyakan pertanyaan sebagai penulis embed dan menggunakan avatar pengguna sebagai ikon di sebelah nama mereka.</li>

        <li><code>embed.set_thumbnail(...)</code>: Menambahkan thumbnail (gambar kecil) yang juga menggunakan avatar pengguna di embed sebagai elemen visual tambahan.</li>

        <li><code>embed.set_footer(...)</code>: Menambahkan teks footer di bagian bawah embed yang menyatakan kapan pertanyaan tersebut diajukan.</li>

        <li><code>await asyncio.sleep(1)</code>: Menambahkan jeda satu detik sebelum respon diedit sebagai bentuk penundaan yang mungkin digunakan untuk alasan estetika atau untuk memastikan respon yang lebih manusiawi.</li>

        <li><code>await interaction.edit_original_response(embed=embed)</code>: Mengedit respon asli yang telah ditunda untuk menambahkan embed yang berisi jawaban AI.</li>

        <li><code>else:</code> Jika tidak ada kunci <code>answer</code> dalam respon dari API, mengirimkan pesan bahwa respon dari AI tidak valid.</li>

        <li><code>await interaction.edit_original_response(content="Failed to get AI response")</code>: Jika status kode dari API bukan 200, mengirimkan pesan bahwa gagal mengambil respon dari AI.</li>

        <li><code>except Exception as error:</code> Jika terjadi kesalahan dalam proses permintaan API atau bagian kode lainnya, blok <code>except</code> akan menangkap kesalahan tersebut dan menampilkan pesan error.</li>

        <li><code>await interaction.edit_original_response(content=f"Error: {error}")</code>: Jika ada error yang tertangkap, pesan error akan dikirim sebagai balasan ke pengguna.</li>
    </ul>
</div>

<h1>Penjelasan Kode Ask Claude Command</h1>

<div class="section">
    <h2>Kode Python: ask_claude</h2>
<pre><code>
@bot.tree.command(name="claude", description="Ask Claude AI anything")
async def ask_claude(interaction: discord.Interaction, keyword: str):
await interaction.response.defer()

try:
    response = requests.get(
        'https://api.your.api',
        params={'chat': keyword, 'options': 'claude-3.5-sonnet'},
        headers={'accept': 'application/json'}
    )
    
    if response.status_code == 200:
        ai_data = response.json()
        
        if 'response' in ai_data:
            embed = create_embed(interaction, ai_data['response'])
            await interaction.followup.send(embed=embed)
        else:
            await interaction.followup.send(f"Invalid AI response: {ai_data}")
    else:
        await interaction.followup.send(f"Failed to get AI response. Status Code: {response.status_code}")
except Exception as error:
    await interaction.followup.send(f"Error: {error}")

def create_embed(interaction: discord.Interaction, ai_response: str) -> discord.Embed:
timestamp = datetime.now().strftime("%A, %B %d, %Y at %H:%M:%S")
embed = discord.Embed(
    title="Claude's Response",
    description=ai_response,
    color=0x2596be
)
embed.set_author(name=f"{interaction.user.name}'s Question", icon_url=interaction.user.display_avatar.url)
embed.set_thumbnail(url=interaction.user.display_avatar.url)
embed.set_footer(text=f"Asked on {timestamp}")
return embed
</code></pre>
</div>

<div class="section">
    <h2>Penjelasan Baris per Baris</h2>
    <ul>
        <li><code>@bot.tree.command(name="claude", description="Ask Claude AI anything")</code>: Mendefinisikan perintah bot bernama <code>claude</code>, di mana pengguna dapat bertanya apa saja kepada AI Claude. Deskripsi ini digunakan oleh Discord untuk memberikan informasi tentang perintah kepada pengguna.</li>

        <li><code>async def ask_claude(interaction: discord.Interaction, keyword: str):</code> Mendefinisikan fungsi asinkron <code>ask_claude</code> yang menerima dua parameter: <code>interaction</code> (yang berisi interaksi di Discord) dan <code>keyword</code> (pertanyaan yang diberikan oleh pengguna).</li>

        <li><code>await interaction.response.defer()</code>: Menunda pengiriman respon agar bot tidak segera menjawab sebelum semua data AI berhasil diambil. Ini digunakan dalam operasi asynchronous untuk mencegah timeout.</li>

        <li><code>try:</code> Memulai blok <code>try</code> untuk menangani potensi kesalahan yang mungkin terjadi selama proses pengambilan respon dari API eksternal.</li>

        <li><code>response = requests.get(...)</code>: Mengirim permintaan GET ke API eksternal <code>https://api.your.api</code>. API ini menyediakan hasil dari Claude AI. Keyword pengguna dikirimkan dalam parameter <code>chat</code> dengan opsi <code>claude-3.5-sonnet</code> yang menentukan versi Claude yang digunakan.</li>

        <li><code>params={'chat': keyword, 'options': 'claude-3.5-sonnet'}</code>: Menentukan parameter permintaan yang berisi kata kunci yang dikirim oleh pengguna (dalam parameter <code>chat</code>), serta memilih opsi AI yang digunakan yaitu Claude 3.5.</li>

        <li><code>headers={'accept': 'application/json'}</code>: Menetapkan bahwa respon dari server harus dalam format JSON agar bisa diproses dengan benar oleh bot.</li>

        <li><code>if response.status_code == 200:</code> Memeriksa apakah server merespon dengan status 200, yang berarti bahwa permintaan ke API berhasil. Jika tidak, pesan error akan dikirim ke pengguna.</li>

        <li><code>ai_data = response.json()</code>: Mengambil data dari API dan mengonversinya dari format JSON ke bentuk dictionary Python agar bisa diolah lebih lanjut.</li>

        <li><code>if 'response' in ai_data:</code> Memeriksa apakah respon dari API mengandung kunci <code>response</code>, yang menyimpan jawaban AI Claude.</li>

        <li><code>embed = create_embed(interaction, ai_data['response'])</code>: Membuat objek <code>embed</code> yang menarik untuk ditampilkan di Discord, dengan menggunakan fungsi <code>create_embed</code> yang telah didefinisikan untuk mengatur tampilan embed.</li>

        <li><code>await interaction.followup.send(embed=embed)</code>: Mengirim embed yang telah dibuat sebagai balasan untuk interaksi pengguna di Discord.</li>

        <li><code>else:</code> Jika respon dari API tidak memiliki kunci <code>response</code>, mengirimkan pesan bahwa respon AI tidak valid, dengan menampilkan isi dari <code>ai_data</code> yang diterima.</li>

        <li><code>except Exception as error:</code> Jika terjadi kesalahan selama proses permintaan atau pengolahan respon, pesan error akan dikirim ke pengguna.</li>

        <li><code>await interaction.followup.send(f"Error: {error}")</code>: Mengirimkan pesan yang berisi informasi kesalahan yang terjadi jika ada exception selama proses eksekusi kode.</li>

        <li><code>def create_embed(...)</code>: Fungsi ini bertanggung jawab untuk membuat dan mengembalikan objek <code>discord.Embed</code> yang akan menampilkan jawaban AI Claude. Fungsi ini digunakan agar struktur kode lebih bersih dan fungsi embed lebih modular.</li>

        <li><code>timestamp = datetime.now().strftime(...)</code>: Mengambil waktu saat ini dan mengubahnya menjadi format yang ramah pengguna, seperti hari, bulan, tanggal, dan waktu. Informasi ini akan ditampilkan di footer embed.</li>

        <li><code>embed = discord.Embed(...)</code>: Membuat objek <code>discord.Embed</code> yang akan digunakan untuk menampilkan informasi dari respon AI dengan tampilan yang lebih baik di Discord.</li>

        <li><code>embed.set_author(...)</code>: Menetapkan pengguna yang menanyakan pertanyaan sebagai penulis dari embed, menggunakan nama dan avatar pengguna.</li>

        <li><code>embed.set_thumbnail(...)</code>: Menambahkan thumbnail avatar pengguna sebagai elemen visual di embed, menjadikan balasan lebih menarik secara visual.</li>

        <li><code>embed.set_footer(...)</code>: Menambahkan informasi waktu kapan pertanyaan diajukan di bagian bawah embed.</li>

        <li><code>return embed</code>: Mengembalikan objek <code>embed</code> yang sudah dikonfigurasi untuk digunakan dalam respon balasan di Discord.</li>
    </ul>
</div>

    <h1>Penjelasan Kode Enhance Image dan Perintah Clean</h1>

    <div class="section">
        <h2>Kode Python: enhance_image dan clean</h2>
<pre><code>
def enhance_image(image_url):
    enhancement_api_url = 'https://api.your/api'
    params = {'url': image_url}
    headers = {'accept': 'image/jpeg'}

    response = requests.get(enhancement_api_url, params=params, headers=headers)
    if response.status_code == 200:
        return response.content
    else:
        return None

@bot.command()
async def clean(ctx):
    if not ctx.message.attachments:
        await ctx.reply("Please attach an image to enhance.")
        return

    image_url = ctx.message.attachments[0].url
    enhanced_image_data = enhance_image(image_url)

    if enhanced_image_data:
        enhanced_image = discord.File(io.BytesIO(enhanced_image_data), filename="enhanced_image.jpg")
        await ctx.reply("Here's the enhanced image:", file=enhanced_image)
    else:
        await ctx.reply("Sorry, I couldn't enhance the image.")
    </code></pre>
    </div>

    <div class="section">
        <h2>Penjelasan Baris per Baris</h2>
        <ul>
            <li><code>def enhance_image(image_url):</code> Mendefinisikan fungsi <code>enhance_image</code> yang menerima satu parameter, yaitu <code>image_url</code>, yang merupakan URL gambar yang akan ditingkatkan kualitasnya.</li>

            <li><code>enhancement_api_url = 'https://api.your/api':</code> Menyimpan URL API eksternal yang digunakan untuk proses peningkatan kualitas gambar ke dalam variabel <code>enhancement_api_url</code>. API ini bertugas untuk melakukan enhancement pada gambar yang dikirimkan.</li>

            <li><code>params = {'url': image_url}</code>: Menyusun parameter permintaan ke API dengan memasukkan URL gambar sebagai nilai untuk kunci <code>url</code>. Parameter ini akan digunakan dalam permintaan HTTP GET untuk mengirim gambar yang akan di-enhance.</li>

            <li><code>headers = {'accept': 'image/jpeg'}</code>: Menyusun header HTTP untuk memberitahukan server bahwa klien mengharapkan respon dalam format gambar JPEG. Ini penting karena hasil dari API adalah gambar yang telah di-enhance.</li>

            <li><code>response = requests.get(enhancement_api_url, params=params, headers=headers)</code>: Mengirim permintaan HTTP GET ke API dengan URL, parameter, dan header yang telah disusun sebelumnya. Hasil dari permintaan disimpan dalam variabel <code>response</code>.</li>

            <li><code>if response.status_code == 200:</code> Memeriksa apakah status kode dari respon HTTP adalah 200, yang berarti permintaan berhasil dan gambar berhasil di-enhance.</li>

            <li><code>return response.content</code>: Jika permintaan berhasil, fungsi ini mengembalikan isi dari respon, yang berupa data biner dari gambar JPEG yang dihasilkan oleh API.</li>

            <li><code>else:</code> Jika status kode dari respon bukan 200 (misalnya jika ada kesalahan di server atau gambar tidak valid), fungsi ini mengembalikan <code>None</code> untuk menandakan bahwa enhancement gagal dilakukan.</li>

            <li><code>@bot.command()</code>: Dekorator ini digunakan untuk mendefinisikan perintah baru untuk bot Discord. Perintah ini akan dapat dipanggil oleh pengguna di Discord dengan menggunakan awalan (prefix) bot.</li>

            <li><code>async def clean(ctx):</code> Mendefinisikan fungsi asinkron <code>clean</code> yang menangani perintah dari pengguna untuk meng-enhance gambar. Parameter <code>ctx</code> mewakili konteks dari perintah yang diberikan oleh pengguna di Discord, termasuk pesan, pengguna, dan server.</li>

            <li><code>if not ctx.message.attachments:</code> Memeriksa apakah ada lampiran gambar yang dikirimkan bersama pesan pengguna. Jika tidak ada, bot akan memberikan balasan bahwa pengguna harus melampirkan gambar.</li>

            <li><code>await ctx.reply("Please attach an image to enhance.")</code>: Jika tidak ada lampiran, bot akan membalas pesan pengguna dengan teks yang meminta pengguna untuk melampirkan gambar yang ingin di-enhance.</li>

            <li><code>return</code>: Menghentikan eksekusi fungsi jika tidak ada gambar yang dilampirkan, sehingga tidak ada langkah lebih lanjut yang diambil.</li>

            <li><code>image_url = ctx.message.attachments[0].url</code>: Mengambil URL dari gambar pertama yang dilampirkan dalam pesan pengguna, dan menyimpannya dalam variabel <code>image_url</code>. Gambar ini yang akan diproses untuk peningkatan kualitas.</li>

            <li><code>enhanced_image_data = enhance_image(image_url)</code>: Memanggil fungsi <code>enhance_image</code> dengan URL gambar yang diperoleh untuk melakukan enhancement. Hasilnya disimpan dalam variabel <code>enhanced_image_data</code>.</li>

            <li><code>if enhanced_image_data:</code> Memeriksa apakah data gambar yang di-enhance berhasil diterima. Jika <code>None</code> (enhancement gagal), pesan error akan dikirimkan ke pengguna.</li>

            <li><code>enhanced_image = discord.File(io.BytesIO(enhanced_image_data), filename="enhanced_image.jpg")</code>: Membuat file gambar baru dari data biner gambar yang telah di-enhance menggunakan <code>io.BytesIO</code>. File ini kemudian dikirimkan ke Discord sebagai lampiran dengan nama <code>enhanced_image.jpg</code>.</li>

            <li><code>await ctx.reply("Here's the enhanced image:", file=enhanced_image)</code>: Mengirim balasan kepada pengguna yang berisi teks dan gambar hasil enhancement sebagai lampiran.</li>

            <li><code>else:</code> Jika gambar tidak dapat di-enhance (misalnya karena server API gagal atau gambar tidak valid), bot akan mengirim pesan bahwa proses enhancement gagal dilakukan.</li>

            <li><code>await ctx.reply("Sorry, I couldn't enhance the image.")</code>: Mengirim balasan ke pengguna bahwa proses enhancement tidak berhasil.</li>
        </ul>
    </div>

    <div class="section">
        <h1>Konfigurasi Error Handler</h1>
    <pre><code>@bot.event
    async def on_command_error(ctx, error):
        if isinstance(error, commands.CommandNotFound):
            error_message = await ctx.reply('Invalid command')
            await error_message.add_reaction('ðŸ‘Ž')
        </code></pre>

    <div class="section">
            <h2>Penjelasan Baris per Baris</h2>
            <ul>
                <li><code>@bot.event</code></span>:Dekorator ini menandakan bahwa fungsi yang didefinisikan di bawahnya adalah event handler. Dalam hal ini, event yang ditangani adalah error yang terjadi saat bot menjalankan command.
                </li>
                <li><code>async def on_command_error(ctx, error):</code></span>:Mendefinisikan fungsi asynchronous untuk menangani error yang terjadi saat command dijalankan. Fungsi ini menerima dua parameter:<ul>   
                <li><code>ctx</code>: Kumpulan konteks informasi terkait perintah yang sedang diproses.</li>
                <li><code>error</code>: Objek yang berisi detail error yang terjadi.</li></ul>
                </li>
                <li><code>if isinstance(error, commands.CommandNotFound):</code></span>:Mengecek apakah error yang terjadi adalah <code>commands.CommandNotFound</code>. Jika ya, maka ini berarti perintah yang diberikan oleh pengguna tidak dikenal oleh bot.
                </li>
                <li><code>error_message = await ctx.reply('Invalid command')</code></span>:Mengirimkan pesan balasan di channel yang sama dengan teks "Invalid command", yang memberitahukan kepada pengguna bahwa perintah yang mereka masukkan tidak dikenali.
                </li>
                <li><code>await error_message.add_reaction('ðŸ‘Ž')</code></span>:Menambahkan reaksi emoji "ðŸ‘Ž" pada pesan balasan yang dikirim sebelumnya. Ini memberikan feedback visual kepada pengguna mengenai kesalahan mereka.
                </li>
            </ul>
<!-- Additional sections omitted for brevity -->

<!-- JavaScript for Highlight.js -->
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<script>
    // Fungsi untuk mengatur tema
    function setTheme(themeName) {
        localStorage.setItem('theme', themeName);
        document.documentElement.className = themeName;
    }

    // Fungsi untuk toggle tema
    function toggleTheme() {
        if (localStorage.getItem('theme') === 'theme-dark') {
            setTheme('theme-light');
        } else {
            setTheme('theme-dark');
        }
    }

    // Set tema saat halaman dimuat
    (function () {
        if (localStorage.getItem('theme') === 'theme-dark') {
            setTheme('theme-dark');
            document.getElementById('theme-toggle').textContent = 'ðŸŒž Light Mode';
        } else {
            setTheme('theme-light');
            document.getElementById('theme-toggle').textContent = 'ðŸŒ™ Dark Mode';
        }
    })();

    // Event listener untuk tombol toggle
    document.getElementById('theme-toggle').addEventListener('click', function() {
        toggleTheme();
        if (localStorage.getItem('theme') === 'theme-dark') {
            this.textContent = 'ðŸŒž Light Mode';
        } else {
            this.textContent = 'ðŸŒ™ Dark Mode';
        }
    });
</script>
</body>
</html>
